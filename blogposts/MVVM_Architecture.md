---
title: 'Modern Mobile App Architecture - MVVM'
date: '2025-03-31'
description: This post is dedicated to providing an introduction to the MVVM (Model-View-ViewModel) architecture framework. In this post, we'll cover the MVVM architecture and how it can be applied to mobile app development.
image: /images/MVVM_Architecture.jpg
---

We’re going to take a look at a modern application architecture framework. This framework is commonly known as MVVM, which is an acronym for Model-View-ViewModel. In the title of this post we call out specifically mobile apps, however this style of app architecture can actually be used for any application. The reason for focusing on mobile apps is so I can draw from my own experiences and use examples specific to mobile app development since that is something I am currently working on. Throughout this post we will talk about what MVVM is, the basics, how to apply MVVM architecture, and some pros of implementing this style of architecture for your app. Let’s get started!

Model-View-ViewModel, is a design concept that focuses on abstracting the user interface and actions from the underlying data. The way this is accomplished is by breaking up an application’s code into various components that are all designed to perform a very specific function based on where it fits into the MVVM architecture. We’ll focus on the actual file structure in a bit, but let’s take a second to visualize MVVM. In simple terms you can see we have the UI layer, where the user interacts with our app. This consists of the view and view model components. Then separately in our data layer we have the model. The model contains our repository and service components that handle the data we’re trying to handle based on our user’s actions (we’ll talk more about these later). 

![MVVM Architecture high level visual overview](/images/MVVM_Architecture.jpg "MVVM Architecture high level visual overview")

Okay, so the first thing we’ll dive into is the view component. While this is technically the second word in the MVVM acronym, we are going to cover this part first as this is what our user sees first and frankly, the only part they’ll really care about. So, what is the view component? The view consists of, well, the view! You can think of this part as what the user sees when interacting with the app. This means any widgets or buttons that a user would interact with. To make our MVVM architecture effective, we will design each view component to only be the visual aspects our users see. 

In the simplest of terms, Views can be described as how the application data is presented to a user. They refer to how the widgets in the app are made up. If you are unfamiliar with the term widget, a widget is any component of the app that you can interact with. Think of how a photo is displayed in an app. The frame and container of that image is known as a widget. These “views” of the widget are responsible for passing events to the view model based on how users interact with said widgets. Going back to our example of a photo displayed in a container, let’s say a user taps the image and then the image expands to take up the whole screen. That interaction is the view (our image container) being tapped, then communicating with the view model to expand to take up the whole screen. 

Well, what exactly does the view model do to make sure our app expands the image container to take up the full screen? A view model contains the logic that controls the state of our user interface. This is what is returning handled data and actions responsible for what our user is doing. For example, the view model will be the separate code portion from the actual UI view that contains the logic saying “If pressed, expand the image view to the full screen”. As noted, it is also responsible for handling data elements based on our user’s actions. If our user double taps the image, the view model may contain logic to log that action as a “like” of the image and pass that data along to the data layer to say “log a like from this user to this image”. This part of our MVVM architecture is extremely important because it combines data from multiple repositories to piece together what needs to be displayed from the user. What I mean by that is the view model pulls image data for what image should be displayed from an image repository, but also handles actions such as “likes” or “saves” to a different repository. 

If we take a look at an image from Flutter’s Architecture documentation on MVVM, you can see how just a single UI view can expand to have multiple data repositories it would need to interact with:

![Flutter MVVM Architecture high level visual overview for UI to data layers](/images/Flutter_MVVM.jpg "Flutter MVVM Architecture high level visual overview for UI to data layers ")

We’ve covered the first part of MVVM architecture that focuses on the user interface portion, but what about the data layer? The data layer is responsible for returning and handling data based on what actions or calls are communicated by the view model. This layer is made up of two different pieces, services and repositories. I’ll note that the goal of the data layer is to have the most simplified and abstracted part of the application. As with any app, the more data and actions for handling the data that are introduced, the more complicated it becomes and easier to introduce bugs.  

First up, repositories. A repository is the main source of truth for your model data. The repository has the responsibility of taking data and altering the raw data into the correct format needed to be stored. By taking data and putting it into a format that is readable and formattable for our database, we’ll be able to reuse it and call it in other portions of our app when needed. That data can be used to be called in our view model for other users if our app was something like a social media app. Going back to our example of images displayed to users. If we have one user uploading different types of images than another user, our database may struggle to handle the various types or even worse, not be able to store and return the images at all. 

Note, there should be a repository class for every different type of data in the app to avoid complexity. This is to ensure when our view models need to present the data prepared by our repository to our users, the app does not get confused by various functions. A view model can call on a bunch of different repositories and a repository can be related to many different view models. Different repositories should never be intertwined with each other or call on each other. If a view model needs data from multiple repositories, the data should be combined at the view model, never a repository calling directly to another. This would introduce complexity and confusion that the MVVM architecture is designed to avoid. 

Next up are services. A service is intended to handle objects that are handled by things outside of the application, for the most part. An example would be something like calling and returning API data (if you don’t know what an API is, take a look at my other blogs on API management: [Effective API Management Part One](https://mahoscorner.com/posts/Effective_API_Management) and [EffectiveAPI Management Part Two](https://mahoscorner.com/posts/Effective_API_Management_Part_Two)). For example, let’s say we have a service that is designed to make a call to an AI model based on the user’s input. We would design a service that’s only job is to take the user input and send it to the AI model’s API and return a response. Service classes really should never hold any state (state refers to the status of where the application is at in its programming such as displaying data for the current visual to the user) as they are intended to be only vessels for data. An app should have a service class per data source, similar to how our application's repositories consist of having a dedicated repository for each data type. These are the bread and butter for whenever data exists outside of your main application. 

When we think of how our repositories and services interact with each other, a few examples of the kind of application logic that can be handled are things such as:
- Caching
- Error handling
- Retry logic
- Refreshing data
- Polling services for new data
- Refreshing data based on user actions

Below is an example of an app that I’ve been working on as a side project that is architected to follow MVVM format. You can see I have dedicated folders for the models, repositories, screens, state, and widgets. Services are actually stored under the “core” folder and that’s where I make calls to my database. If you’re asking why there are screens under journal and also under auth, that is because we have screens for different functions and the auth screens are only for handling the auth stuff for the user. The intent of this picture is to help visualize some of the many components you have to build to make sure you follow MVVM best practices and avoid creating performance issues or app complexity down the road. I will say, the cool thing about flutter is you can build your app for any platform, you just have to choose which of the ones you want to focus on. In my example, this is for mobile apps so the main platforms are Android and iOS, but all I have to do is write it in dart (flutter’s main programming language) once and then it compiles to both. Flutter includes an example of their use case here: [Flutter Case Study](https://docs.flutter.dev/app-architecture/case-study). 
 
![MVVM Architecture example](/images/MVVM_App_Example.jpg "MVVM Architecture example")

So, to recap what we’ve covered, MVVM is a modern architecture approach designed to simplify how users view and interact with an application, to separate them away from the underlying data components. By breaking out the UI layer into a View and View Model, we can build components that are designed to only perform functions of what the app should look like. By separating the data layer into repositories and services, we decrease risk of having data conflicts and complexity of data management on the backend. All of this will make our application code easier to read, more testable, and avoid bugs. 

The beauty of this style of architecture is if we need to make a change to our application, we only need to change one component of our MVVM architecture. For example, let’s say there was a business decision to change cloud providers. Normally this requires a ton of resources and if the application is not well maintained, it can be very challenging to perform. Well, if we have MVVM architecture, this becomes simpler. Take for example how data gets stored in a cloud database for an app. If the original service component that was responsible for calling our cloud provider’s database and storing data needs to change, well now we can effectively just swap out the old cloud provider info with our new cloud provider info and it should not impact the app. It’s intended to be as simple as swapping out API keys, if that’s how you manage data between your database. 

If you enjoyed this article, I would recommend diving deeper into the official material the Flutter team put together for MVVM architecture, as it was a lot of the inspiration for this post and my current app development. You can find it here: [Flutter MVVM Architecture](https://docs.flutter.dev/app-architecture/guide). 

Hopefully you learned something from this and as always feel free to let me know if you have any feedback or questions! 
